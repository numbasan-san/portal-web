<!-- definition.html -->
{% extends "./partials/base.html" %}

{% block body %}
<br>
<div class="container container-fluid page-container">
    <h2 class="text-center text-uppercase">{{ data.title }}</h2>
    <hr style="border: none; height: 2px; background: var(--orange);">
    
    <div class="row">
        <div class="col-lg-12">
            <div style="background: transparent; border: none;">
                <div style="padding: 0;">
                    <h4 class="fw-bold mb-4" style="color: var(--orange); font-size: 1.8rem;">Definición</h4>
                    <p class="fs-5" style="line-height: 1.7;">
                        Un <strong class="fw-bold">compilador</strong> es un programa que traduce código fuente escrito en un lenguaje de programación (alto nivel) a otra representación, típicamente código de máquina o código intermedio, que pueda ser ejecutado por una máquina o por otra capa de software. El propósito principal es transformar, verificar y optimizar el programa manteniendo su semántica.
                    </p>
                    
                    <h4 class="mt-5 fw-bold mb-4" style="color: var(--orange); font-size: 1.8rem;">Vínculo con la Teoría de Autómatas y Lenguajes Formales
                    </h4>
                    <p class="fs-5 mb-4" style="color: var(--text-secondary);">
                        La construcción de compiladores se apoya fuertemente en teoría de lenguajes y autómatas:
                    </p>
                    
                    <div>
                        <div class="mb-4 p-3" style="background: rgba(255, 132, 0, 0.05); border-left: 4px solid var(--orange);">
                            <label class="fw-bold d-block mb-2 fs-5" style="color: var(--orange);">
                                <i class="fas fa-language me-2"></i>Lenguajes formales y gramáticas
                            </label>
                            <p class="mb-0 fs-6" style="color: var(--text-secondary); line-height: 1.6;">
                                La sintaxis de los lenguajes de programación se especifica mediante gramáticas formales (comúnmente gramáticas libre de contexto —CFGs— para la sintaxis estructurada). Estas gramáticas permiten definir de forma precisa qué secuencias de tokens constituyen programas válidos.
                            </p>
                        </div>
                        
                        <div class="mb-4 p-3" style="background: rgba(255, 132, 0, 0.05); border-left: 4px solid var(--orange);">
                            <label class="fw-bold d-block mb-2 fs-5" style="color: var(--orange);">
                                <i class="fas fa-project-diagram me-2"></i>Autómatas finitos y análisis léxico
                            </label>
                            <p class="mb-0 fs-6" style="color: var(--text-secondary); line-height: 1.6;">
                                El análisis léxico transforma la secuencia de caracteres en una secuencia de tokens. Las expresiones regulares (o gramáticas regulares) se usan para describir tokens y se implementan con autómatas finitos deterministas (DFA) o no deterministas (NFA). Herramientas como lex/flex generan analizadores léxicos a partir de expresiones regulares construyendo autómatas.
                            </p>
                        </div>
                        
                        <div class="mb-4 p-3" style="background: rgba(255, 132, 0, 0.05); border-left: 4px solid var(--orange);">
                            <label class="fw-bold d-block mb-2 fs-5" style="color: var(--orange);">
                                <i class="fas fa-layer-group me-2"></i>Autómatas con pila y análisis sintáctico
                            </label>
                            <p class="mb-0 fs-6" style="color: var(--text-secondary); line-height: 1.6;">
                                El reconocimiento de estructuras sintácticas impone jerarquías que normalmente requieren gramáticas libres de contexto. Los analizadores sintácticos (parsers) emplean parsers descendentes (LL) o ascendentes (LR) que se basan en conceptos de autómatas con pila (pushdown automata). Herramientas como yacc/bison generan analizadores sintácticos a partir de una gramática CFG.
                            </p>
                        </div>
                        
                        <div class="p-3" style="background: rgba(255, 132, 0, 0.05); border-left: 4px solid var(--orange);">
                            <label class="fw-bold d-block mb-2 fs-5" style="color: var(--orange);">
                                <i class="fas fa-brain me-2"></i>Semántica y lógica formal
                            </label>
                            <p class="mb-0 fs-6" style="color: var(--text-secondary); line-height: 1.6;">
                                La comprobación semántica (tipado, alcance, consistencia) utiliza teorías formales: sistemas de tipos (teorías de tipo), inferencia de tipos (algoritmos como Hindley–Milner), y formalización de la semántica (semántica operativa, denotacional y axiomatica) para razonar sobre el comportamiento del programa.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}